{"componentChunkName":"component---src-pages-applications-liberty-liberty-deploy-cloud-native-toolkit-mdx","path":"/applications/liberty/liberty-deploy-cloud-native-toolkit/","result":{"pageContext":{"frontmatter":{"title":"Modernizing runtimes with Liberty - Deploy using the Cloud Native Toolkit","description":"This section covers how to deploy the application to Red Hat OpenShift using the pipelines provided by the Cloud Native Toolkit. The Cloud Native Toolkit installs and configures an open-source collection of assets to bootstrap Red Hat OpenShift ready for applications to be developed and deployed."},"relativePagePath":"/applications/liberty/liberty-deploy-cloud-native-toolkit.mdx","titleType":"append","MdxNode":{"id":"f68aa911-26ac-5898-aee5-3cc2ad8bbc48","children":[],"parent":"df5f18b0-f3bb-57a6-af7a-e716baf204e0","internal":{"content":"---\ntitle: Modernizing runtimes with Liberty - Deploy using the Cloud Native Toolkit\ndescription: This section covers how to deploy the application to Red Hat OpenShift using the pipelines provided by the Cloud Native Toolkit. The Cloud Native Toolkit installs and configures an open-source collection of assets to bootstrap Red Hat OpenShift ready for applications to be developed and deployed.\n---\n\nexport const Title = () => (\n  <span>\nModernizing runtimes with Liberty <br/> <h2>Deploy using Cloud Native Toolkit Pipelines</h2>\n  </span>\n);\n\n<PageDescription>\n\nThis section covers how to deploy the CustomerOrderServices application to Red Hat OpenShift using the pipelines provided by the [Cloud Native Toolkit](https://cloudnativetoolkit.dev)\n</PageDescription>\n\n## Summary\nThis section has the following steps:\n\n<AnchorLinks small>\n  <AnchorLink>Cloud Native Toolkit pipelines</AnchorLink>\n  <AnchorLink>Prerequisites</AnchorLink>\n  <AnchorLink>Create application database</AnchorLink>\n  <AnchorLink>Create the application in Git</AnchorLink>\n  <AnchorLink>Clone the application code locally</AnchorLink>\n  <AnchorLink>Configure the application namespace</AnchorLink>\n  <AnchorLink>Register the application with the Toolkit pipeline</AnchorLink>\n  <AnchorLink>Execute the Toolkit pipeline</AnchorLink>\n  <AnchorLink>Review the Sonar Scan for the application</AnchorLink>\n  <AnchorLink>Validate the application</AnchorLink>\n  <AnchorLink>Review and Next Steps</AnchorLink>\n</AnchorLinks>\n\n## Cloud Native Toolkit pipelines\n[Cloud Native Toolkit](https://cloudnativetoolkit.dev) is an open-source collection of assets that provide an environment for developing cloud-native applications for deployment within Red Hat OpenShift and Kubernetes. It embodies IBM Garage Method principles and practices for consistently developed applications, incorporating best practices that increase developer velocity for efficient delivery of business value.\n\nThe diagram below shows the flow of the pipeline which starts when the developer checks their code in to Git:\n\n  ![Pipeline](images/liberty-deploy/toolkit-pipeline1.jpg)\n\n- test: the application code is compiled and unit tests are executed using [Maven](https://maven.apache.org/) before the static code is analyzed for quality using [SonarQube](https://www.sonarqube.org/).\n\n- build: the container image for the application is created using [buildah](https://buildah.io) and pushed to the Image Registry in the local OpenShift cluster\n\n- trivy-scan: the container image in the local Image Registry is scanned for vulnerabilities using [Trivy](https://github.com/aquasecurity/trivy)\n\n- deploy: deploy the application to the `dev` namespace\n\n- health-check: validate the the application is functioning correctly in the `dev` namespace. Automated testing may occur at this step but is out of the scope of this solution.\n\n- tag-release: create a new 'release' for the application in the Git repository\n\n- img-release: tag and push the container image to the central Image Repository\n\n- scan: scan the container image in the central Image Registry using [IBM Vulnerability Advisor](https://cloud.ibm.com/apidocs/container-registry/va)\n\n- helm-release: package a helm release for the application and load it in to the central Artifact Repository [Artifactory](https://jfrog.com/artifactory)\n\n- gitops: update the GitOps repository with the latest helm release information to trigger [ArgoCD](https://argoproj.github.io/argo-cd/) to deploy the application to the `test` namespace\n\n## Deploy the Application\nThe following steps will deploy the modernized Customer Order Services application in a WebSphere Liberty container to a Red Hat OpenShift cluster.\n\n### Prerequisites\nYou will need the following:\n\n- [Git CLI](https://git-scm.com/book/en/v2/Getting-Started-Installing-Git)\n- [GitHub Personal Access Token](https://cloudnativetoolkit.dev/getting-started/prereqs#configure-github-personal-access-token)\n- Red Hat OpenShift Container Platfrom 4.4 with Cluster Admin permissions\n- [Cloud Native Toolkit installed and configured](https://cloudnativetoolkit.dev/getting-started-day-0/plan-installation/ibm-cloud)\n- [igc CLI](https://cloudnativetoolkit.dev/getting-started/cli)\n- [oc CLI](https://docs.openshift.com/container-platform/3.11/cli_reference/get_started_cli.html)\n- DB2 Database\n\n### Create application database\nAs said in the prerequisites section above, the Customer Order Services application uses uses DB2 as its database.\n\nIf you want to use a pre-configured DB2 database in a container in OpenShift, use the instructions provided [here](db2)\n\nAlternatively, if you have a DB2 server that you want to use, follow these steps to create the appropriate database, tables and data the application needs to:\n\n- Copy the createOrderDB.sql and initialDataSet.sql files you can find in the Common directory of this repository over to the db2 host machine (or git clone the repository) in order to execute them later.\n\n- ssh into the db2 host\n\n- Change to the db2 instance user: `su {database_instance_name}``\n\n- Start db2: `db2start`\n\n- Create the ORDERDB database: `db2 create database ORDERDB`\n\n- Connect to the ORDERDB database: `db2 connect to ORDERDB`\n\n- Execute the createOrderDB.sql script you copied over in step 1 in order to create the appropriate tables, relationships, primary keys, etc: `db2 -tf createOrderDB.sql`\n\n- Execute the initialDataSet.sql script you copied over in step 1 to populate the ORDERDB database with the needed initial data set: `db2 -tf initialDataSet.sql`\n\nIf you want to re-run the scripts, please make sure you drop the databases and create them again.\n\n### Create the application in Git\nCreate an instance of the `template GitHub repository` in your own GitHub account using the following steps:\n\n- Click [here](https://github.com/ibm-cloud-architecture/appmod-liberty-toolkit/generate) to create an instance of the template\n\n- Ensure that the `owner` field is set correctly, and then enter a unique `repository name`\n\n- Leave the repository as a `public` repository and click **Create repository from this template**\n\n  ![template](images/liberty-deploy/toolkit-pipeline-2.jpg)\n\n### Clone the application code locally\nThe newly created repository will be shown in your browser. In order to clone the code locally, use the following steps\n\n- In the browser, click the green **Code** button and use the **copy* icon to copy the `https://github.com/...` URL\n\n- Navigate to a `directory/folder` on your local machine where you want to clone the code\n\n- Enter the following command, pasting the copied URL after the `git clone `:\n\n```\ngit clone <URL>\n```\n\n- Navigate in to the cloned code. The `folder` will have the same name as the `repository`\n\n```\ncd <REPO_NAME>\n```\n\n  ![template](images/liberty-deploy/toolkit-pipeline-3.jpg)\n\n### Configure the application namespace\nCreate a new OpenShift project for the `dev` namespace using the following steps\n\n- Issue the following command to new OpenShift `project` and configure it with the required `Service Accounts`, `Config Maps` and `Secrets`\n\n```\noc sync cos-with-toolkit-dev --dev\n```\n\n- Issue the following command to set the current project to `cos-with-toolkit-dev`\n\n```\noc project cos-with-toolkit-dev\n```\n\n### Register the application with the Toolkit pipeline\nIn order to configure the application to use the pipeline provided by the toolkit, use the following steps\n\n- Issue the following command\n\n```\noc pipeline\n```\n\n- When prompted to **Select the type of pipeline that should be run**, select `Tekton`\n\n- When prompted for your **git credentials** use your `username`, `API token` and the `master` branch\n\n- When prompted to **Select the Pipeline to use in the PipelineRun**, select `ibm-appmod-liberty`\n\n- When prompted **? scan-image: Enable the pipeline to scan the image for vulnerabilities? (Y/n)**, enter `Y`\n\n  ![template](images/liberty-deploy/toolkit-pipeline-4.jpg)\n\n- When prompted **? health-endpoint: Endpoint to check health after deployment, liberty uses / not /health? (/)**, press enter\n\n- When promoted **? java-bin-path: The path to the java binaries. The default value is \"target\"? (target)**, enter `CustomerOrderServicesApp/target`\n\nThe result will be a specialized `tekton pipeline` for Liberty applications that has been configured with a **WebHook** from your `GitHub repository`.\n\n### Review the Sonar Scan for the application\n- Use the `Cloud Native Toolkit Dashboard` to find the link to SonarQube in your environment\n\n```\nigc dashboard\n```\n  ![template](images/liberty-deploy/toolkit-pipeline-13.jpg)\n\n\n- Once in the SonaQube UI, click **Projects** and review the results for your project\n  ![template](images/liberty-deploy/toolkit-pipeline-14.jpg)\n\n### Validate the application\nNow that the pipeline is complete, validate the Customer Order Services application is deployed and running in `cos-with-tekton-dev` project\n\n- In the OpenShift Console, navigate to **Workloads --> Deployments** view and click on the `cos-with-toolkit` Deployment to view deployment details\n  ![template](images/liberty-deploy/toolkit-pipeline-15.jpg)\n\n\n- Next, navigate to the **Networking --> Routes** view and click on the **Location** to open a browser session for the application\n  ![template](images/liberty-deploy/toolkit-pipeline-16.jpg)\n\n\n- Add `/CustomerOrderServicesWeb` to the end of the URL in the browser to access the application\n\n  ![Dev Running](images/liberty-deploy/dev-running.jpg)\n\n- Log in to the application with `username: rbarcia` and `password: bl0wfish`\n\n## Review and Next Steps\nIn this section you configured a CI/CD pipeline for the CustomerOrderServices application that builds, tests, scans and validates the application code and Container Image and results in the application running in a `dev` environment.\n","type":"Mdx","contentDigest":"348e8b09745aedd34e1f69de5378c1e0","counter":448,"owner":"gatsby-plugin-mdx"},"frontmatter":{"title":"Modernizing runtimes with Liberty - Deploy using the Cloud Native Toolkit","description":"This section covers how to deploy the application to Red Hat OpenShift using the pipelines provided by the Cloud Native Toolkit. The Cloud Native Toolkit installs and configures an open-source collection of assets to bootstrap Red Hat OpenShift ready for applications to be developed and deployed."},"exports":{},"rawBody":"---\ntitle: Modernizing runtimes with Liberty - Deploy using the Cloud Native Toolkit\ndescription: This section covers how to deploy the application to Red Hat OpenShift using the pipelines provided by the Cloud Native Toolkit. The Cloud Native Toolkit installs and configures an open-source collection of assets to bootstrap Red Hat OpenShift ready for applications to be developed and deployed.\n---\n\nexport const Title = () => (\n  <span>\nModernizing runtimes with Liberty <br/> <h2>Deploy using Cloud Native Toolkit Pipelines</h2>\n  </span>\n);\n\n<PageDescription>\n\nThis section covers how to deploy the CustomerOrderServices application to Red Hat OpenShift using the pipelines provided by the [Cloud Native Toolkit](https://cloudnativetoolkit.dev)\n</PageDescription>\n\n## Summary\nThis section has the following steps:\n\n<AnchorLinks small>\n  <AnchorLink>Cloud Native Toolkit pipelines</AnchorLink>\n  <AnchorLink>Prerequisites</AnchorLink>\n  <AnchorLink>Create application database</AnchorLink>\n  <AnchorLink>Create the application in Git</AnchorLink>\n  <AnchorLink>Clone the application code locally</AnchorLink>\n  <AnchorLink>Configure the application namespace</AnchorLink>\n  <AnchorLink>Register the application with the Toolkit pipeline</AnchorLink>\n  <AnchorLink>Execute the Toolkit pipeline</AnchorLink>\n  <AnchorLink>Review the Sonar Scan for the application</AnchorLink>\n  <AnchorLink>Validate the application</AnchorLink>\n  <AnchorLink>Review and Next Steps</AnchorLink>\n</AnchorLinks>\n\n## Cloud Native Toolkit pipelines\n[Cloud Native Toolkit](https://cloudnativetoolkit.dev) is an open-source collection of assets that provide an environment for developing cloud-native applications for deployment within Red Hat OpenShift and Kubernetes. It embodies IBM Garage Method principles and practices for consistently developed applications, incorporating best practices that increase developer velocity for efficient delivery of business value.\n\nThe diagram below shows the flow of the pipeline which starts when the developer checks their code in to Git:\n\n  ![Pipeline](images/liberty-deploy/toolkit-pipeline1.jpg)\n\n- test: the application code is compiled and unit tests are executed using [Maven](https://maven.apache.org/) before the static code is analyzed for quality using [SonarQube](https://www.sonarqube.org/).\n\n- build: the container image for the application is created using [buildah](https://buildah.io) and pushed to the Image Registry in the local OpenShift cluster\n\n- trivy-scan: the container image in the local Image Registry is scanned for vulnerabilities using [Trivy](https://github.com/aquasecurity/trivy)\n\n- deploy: deploy the application to the `dev` namespace\n\n- health-check: validate the the application is functioning correctly in the `dev` namespace. Automated testing may occur at this step but is out of the scope of this solution.\n\n- tag-release: create a new 'release' for the application in the Git repository\n\n- img-release: tag and push the container image to the central Image Repository\n\n- scan: scan the container image in the central Image Registry using [IBM Vulnerability Advisor](https://cloud.ibm.com/apidocs/container-registry/va)\n\n- helm-release: package a helm release for the application and load it in to the central Artifact Repository [Artifactory](https://jfrog.com/artifactory)\n\n- gitops: update the GitOps repository with the latest helm release information to trigger [ArgoCD](https://argoproj.github.io/argo-cd/) to deploy the application to the `test` namespace\n\n## Deploy the Application\nThe following steps will deploy the modernized Customer Order Services application in a WebSphere Liberty container to a Red Hat OpenShift cluster.\n\n### Prerequisites\nYou will need the following:\n\n- [Git CLI](https://git-scm.com/book/en/v2/Getting-Started-Installing-Git)\n- [GitHub Personal Access Token](https://cloudnativetoolkit.dev/getting-started/prereqs#configure-github-personal-access-token)\n- Red Hat OpenShift Container Platfrom 4.4 with Cluster Admin permissions\n- [Cloud Native Toolkit installed and configured](https://cloudnativetoolkit.dev/getting-started-day-0/plan-installation/ibm-cloud)\n- [igc CLI](https://cloudnativetoolkit.dev/getting-started/cli)\n- [oc CLI](https://docs.openshift.com/container-platform/3.11/cli_reference/get_started_cli.html)\n- DB2 Database\n\n### Create application database\nAs said in the prerequisites section above, the Customer Order Services application uses uses DB2 as its database.\n\nIf you want to use a pre-configured DB2 database in a container in OpenShift, use the instructions provided [here](db2)\n\nAlternatively, if you have a DB2 server that you want to use, follow these steps to create the appropriate database, tables and data the application needs to:\n\n- Copy the createOrderDB.sql and initialDataSet.sql files you can find in the Common directory of this repository over to the db2 host machine (or git clone the repository) in order to execute them later.\n\n- ssh into the db2 host\n\n- Change to the db2 instance user: `su {database_instance_name}``\n\n- Start db2: `db2start`\n\n- Create the ORDERDB database: `db2 create database ORDERDB`\n\n- Connect to the ORDERDB database: `db2 connect to ORDERDB`\n\n- Execute the createOrderDB.sql script you copied over in step 1 in order to create the appropriate tables, relationships, primary keys, etc: `db2 -tf createOrderDB.sql`\n\n- Execute the initialDataSet.sql script you copied over in step 1 to populate the ORDERDB database with the needed initial data set: `db2 -tf initialDataSet.sql`\n\nIf you want to re-run the scripts, please make sure you drop the databases and create them again.\n\n### Create the application in Git\nCreate an instance of the `template GitHub repository` in your own GitHub account using the following steps:\n\n- Click [here](https://github.com/ibm-cloud-architecture/appmod-liberty-toolkit/generate) to create an instance of the template\n\n- Ensure that the `owner` field is set correctly, and then enter a unique `repository name`\n\n- Leave the repository as a `public` repository and click **Create repository from this template**\n\n  ![template](images/liberty-deploy/toolkit-pipeline-2.jpg)\n\n### Clone the application code locally\nThe newly created repository will be shown in your browser. In order to clone the code locally, use the following steps\n\n- In the browser, click the green **Code** button and use the **copy* icon to copy the `https://github.com/...` URL\n\n- Navigate to a `directory/folder` on your local machine where you want to clone the code\n\n- Enter the following command, pasting the copied URL after the `git clone `:\n\n```\ngit clone <URL>\n```\n\n- Navigate in to the cloned code. The `folder` will have the same name as the `repository`\n\n```\ncd <REPO_NAME>\n```\n\n  ![template](images/liberty-deploy/toolkit-pipeline-3.jpg)\n\n### Configure the application namespace\nCreate a new OpenShift project for the `dev` namespace using the following steps\n\n- Issue the following command to new OpenShift `project` and configure it with the required `Service Accounts`, `Config Maps` and `Secrets`\n\n```\noc sync cos-with-toolkit-dev --dev\n```\n\n- Issue the following command to set the current project to `cos-with-toolkit-dev`\n\n```\noc project cos-with-toolkit-dev\n```\n\n### Register the application with the Toolkit pipeline\nIn order to configure the application to use the pipeline provided by the toolkit, use the following steps\n\n- Issue the following command\n\n```\noc pipeline\n```\n\n- When prompted to **Select the type of pipeline that should be run**, select `Tekton`\n\n- When prompted for your **git credentials** use your `username`, `API token` and the `master` branch\n\n- When prompted to **Select the Pipeline to use in the PipelineRun**, select `ibm-appmod-liberty`\n\n- When prompted **? scan-image: Enable the pipeline to scan the image for vulnerabilities? (Y/n)**, enter `Y`\n\n  ![template](images/liberty-deploy/toolkit-pipeline-4.jpg)\n\n- When prompted **? health-endpoint: Endpoint to check health after deployment, liberty uses / not /health? (/)**, press enter\n\n- When promoted **? java-bin-path: The path to the java binaries. The default value is \"target\"? (target)**, enter `CustomerOrderServicesApp/target`\n\nThe result will be a specialized `tekton pipeline` for Liberty applications that has been configured with a **WebHook** from your `GitHub repository`.\n\n### Review the Sonar Scan for the application\n- Use the `Cloud Native Toolkit Dashboard` to find the link to SonarQube in your environment\n\n```\nigc dashboard\n```\n  ![template](images/liberty-deploy/toolkit-pipeline-13.jpg)\n\n\n- Once in the SonaQube UI, click **Projects** and review the results for your project\n  ![template](images/liberty-deploy/toolkit-pipeline-14.jpg)\n\n### Validate the application\nNow that the pipeline is complete, validate the Customer Order Services application is deployed and running in `cos-with-tekton-dev` project\n\n- In the OpenShift Console, navigate to **Workloads --> Deployments** view and click on the `cos-with-toolkit` Deployment to view deployment details\n  ![template](images/liberty-deploy/toolkit-pipeline-15.jpg)\n\n\n- Next, navigate to the **Networking --> Routes** view and click on the **Location** to open a browser session for the application\n  ![template](images/liberty-deploy/toolkit-pipeline-16.jpg)\n\n\n- Add `/CustomerOrderServicesWeb` to the end of the URL in the browser to access the application\n\n  ![Dev Running](images/liberty-deploy/dev-running.jpg)\n\n- Log in to the application with `username: rbarcia` and `password: bl0wfish`\n\n## Review and Next Steps\nIn this section you configured a CI/CD pipeline for the CustomerOrderServices application that builds, tests, scans and validates the application code and Container Image and results in the application running in a `dev` environment.\n","fileAbsolutePath":"/home/runner/work/modernization-playbook/modernization-playbook/src/pages/applications/liberty/liberty-deploy-cloud-native-toolkit.mdx"}}}}