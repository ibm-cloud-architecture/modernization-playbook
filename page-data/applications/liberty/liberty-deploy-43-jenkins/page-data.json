{"componentChunkName":"component---src-pages-applications-liberty-liberty-deploy-43-jenkins-mdx","path":"/applications/liberty/liberty-deploy-43-jenkins/","result":{"pageContext":{"frontmatter":{"title":"Modernizing runtimes with Liberty - Deploy using Jenkins on OCP 4.3","description":"This section covers how to deploy the application to Red Hat OpenShift 4.3 using a Jenkins automated CI/CD pipeline. The diagram below shows the flow of the pipeline which starts when the developer checks their code in to Git and ends with the application being deployed in Production."},"relativePagePath":"/applications/liberty/liberty-deploy-43-jenkins.mdx","titleType":"append","MdxNode":{"id":"3df044b1-0b80-5139-af52-c053bc7cabf5","children":[],"parent":"e624b0fc-e440-5f09-be34-d74a12091b26","internal":{"content":"---\ntitle: Modernizing runtimes with Liberty - Deploy using Jenkins on OCP 4.3\ndescription: This section covers how to deploy the application to Red Hat OpenShift 4.3 using a Jenkins automated CI/CD pipeline. The diagram below shows the flow of the pipeline which starts when the developer checks their code in to Git and ends with the application being deployed in Production.\n---\n\nexport const Title = () => (\n  <span>\nModernizing runtimes with Liberty <br/> <h2>Deploy using Jenkins on OCP 4.3</h2>\n  </span>\n);\n\n<PageDescription>\nThis section covers how to deploy the application to Red Hat OpenShift 4.3 using a Jenkins automated CI/CD pipeline. The diagram below shows the flow of the pipeline which starts when the developer checks their code in to Git and ends with the application being deployed in Production.\n</PageDescription>\n\n  ![Pipeline](images/liberty-deploy/overview.jpg)\n\n  1. the developer checks their code in to `git`\n  2. a `webhook` automatically triggers the Jenkins Pipeline in the RHOS cluster\n  3. the pipeline checks out the code from `git` and uses `maven` to build and test the application\n  4. the `oc start build` command is used to build a `docker` image for the application\n  5. the image is added to the `ImageStream` and pushed to the `docker registry` in the RHOS cluster\n  6. the image is then `tagged` for the `dev` project\n  7. the `deployment` running in the `dev` project is restarted using the newly created image\n  8. the image is then `tagged` for the `stage` project\n  9. the `deployment` running in the `stage` project is restarted using the newly created image\n  10. the developer is prompted to `approve` the deployment to production\n  11. the image is then `tagged` for the `prod` project\n  12. the `deployment` running in the `prod` project is restarted using the newly created image\n\n## Deploy the Application\nThe following steps will deploy the modernized Customer Order Services application in a WebSphere Liberty container to a Red Hat OpenShift cluster.\n\n### Prerequisites\nYou will need the following:\n\n- [Git CLI](https://git-scm.com/book/en/v2/Getting-Started-Installing-Git)\n- Red Hat OpenShift 4.3 with Cluster Admin permissions\n- [oc CLI](https://docs.openshift.com/container-platform/3.11/cli_reference/get_started_cli.html)\n- DB2 Database\n\n### Getting the project repository\nYou can clone the repository from its main GitHub repository page and checkout the appropriate branch for this version of the application.\n\n```\ngit clone https://github.com/ibm-cloud-architecture/appmod-liberty-jenkins.git\ncd appmod-liberty-jenkins\n```\n\n### Create application database infrastructure\nAs said in the prerequisites section above, the Customer Order Services application uses uses DB2 as its database. Follow these steps to create the appropriate database, tables and data the application needs to:\n\n- Copy the createOrderDB.sql and initialDataSet.sql files you can find in the Common directory of this repository over to the db2 host machine (or git clone the repository) in order to execute them later.\n\n- ssh into the db2 host\n\n- Change to the db2 instance user: `su {database_instance_name}``\n\n- Start db2: `db2start`\n\n- Create the ORDERDB database: `db2 create database ORDERDB`\n\n- Connect to the ORDERDB database: `db2 connect to ORDERDB`\n\n- Execute the createOrderDB.sql script you copied over in step 1 in order to create the appropriate tables, relationships, primary keys, etc: `db2 -tf createOrderDB.sql`\n\n- Execute the initialDataSet.sql script you copied over in step 1 to populate the ORDERDB database with the needed initial data set: `db2 -tf initialDataSet.sql`\n\nIf you want to re-run the scripts, please make sure you drop the databases and create them again.\n\n### Create the Security Context Constraint\nIn order to deploy and run the WebSphere Liberty Docker image in an OpenShift cluster, we first need to configure certain security aspects for the cluster. The `Security Context Constraint` provided [here](https://github.com/ibm-cloud-architecture/appmod-liberty-jenkins/blob/master/Deployment/OpenShift/ssc.yaml) grants the [service account](https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/) that the WebSphere Liberty Docker container is running under the required privileges to function correctly.\n\n### Create the projects\nFour Red Hat OpenShift projects are required in this scenario:\n\n- Build: this project will contain the Jenkins server and the artifacts used to build the application image\n- Dev: this is the `development` environment for this application\n- Stage: this is the `staging` environment for this application\n- Prod: this is the `production` environment for this application\n\nThe file provided [here](https://github.com/ibm-cloud-architecture/appmod-liberty-jenkins/blob/master/Deployment/OpenShift/liberty-projects.yaml) contains the definitions for the four projects in a single file to make creation easier\n\nIssue the command shown below to create the projects\n```\noc create -f liberty-projects.yaml\n```\n\n### Deploy Jenkins\nSome Red Hat OpenShift clusters are configured to automatically provision a Jenkins instance in a build project. The steps below can be used if your cluster is not configured for automatic Jenkins provisioning:\n\n```\noc project cos-liberty-build\noc new-app jenkins-persistent\n```\n\n## Update the Jenkins service account\nDuring provisioning of the Jenkins master a service account with the name `jenkins` is created. This service account has privileges to create new artifacts only in the project that it is running in. In this scenario Jenkins will need to create artifacts in the `dev`, `stage` and `prod` projects.\n\nIssue the commands below to allow the `jenkins` service account to `edit` artifacts in the `dev`, `stage` and `prod` projects.\n\n```\noc policy add-role-to-user edit system:serviceaccount:cos-liberty-build:jenkins -n cos-liberty-dev\noc policy add-role-to-user edit system:serviceaccount:cos-liberty-build:jenkins -n cos-liberty-stage\noc policy add-role-to-user edit system:serviceaccount:cos-liberty-build:jenkins -n cos-liberty-prod\n```\n\n### Import the deployment templates\nRed Hat OpenShift [templates](https://docs.openshift.com/container-platform/3.11/dev_guide/templates.html) are used to make artifact creation easier and repeatable. The template definition provided [here](https://github.com/ibm-cloud-architecture/appmod-liberty-jenkins/blob/master/Deployment/OpenShift/template-liberty-deploy.yaml) defines a Kubernetes [`Service`](https://kubernetes.io/docs/concepts/services-networking/service/), [`Route`](https://docs.openshift.com/container-platform/3.11/architecture/networking/routes.html) and [`DeploymentConfig`](https://docs.openshift.com/container-platform/3.11/architecture/core_concepts/deployments.html#deployments-and-deployment-configurations) for the CustomerOrderServices application.\n\nThe `gse-liberty-deploy` template defines the following:\n\n- `service` listening on ports `9080`, `9443` and `9082`\n- `route` to expose the `9443` port externally\n- `DeploymentConfig` to host the WebSphere Liberty container.\n    - The `image` for the container is taken from the [`ImageStream`](https://docs.openshift.com/container-platform/3.11/dev_guide/managing_images.html) that will be populated by the Jenkins pipeline.\n    - `environment variables` are defined for the DB2 database used by the application allowing for environment specific information to be injected\n    - [Probes](https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-probes/) for `liveness` and `readiness` are defined to check port 9443 is active\n    - The `securityContext` is set to allow read/write access to the filesystem and to run the container as `user 1001`\n    - The deployment will be updated if a new image is loaded to the `ImageStream` or if a change to the configuration is detected.\n\nIssue the commands below to load the template named `gse-liberty-deploy` in the `dev`, `stage` and `prod` projects.\n\n```\noc create -f template-liberty-deploy.yaml -n cos-liberty-dev\noc create -f template-liberty-deploy.yaml -n cos-liberty-stage\noc create -f template-liberty-deploy.yaml -n cos-liberty-prod\n```\n\n### Create the deployment definitions\nIn this step the `gse-liberty-deploy` template will be used to create a Red Hat OpenShift [application](https://docs.openshift.com/container-platform/3.11/dev_guide/application_lifecycle/new_app.html) named `cos-liberty` in the `dev`, `stage` and `prod` namespaces.\n\nThe result will be:\n\n- `service` listening on ports `9080`, `9443` and `9082`\n- `route` to expose the `9443` port externally\n- `DeploymentConfig` to host the WebSphere Liberty container. The deployment config will wait for a `docker image` to be loaded in to the `ImageStream` by the Jenkins pipeline.\n\nIssue the following commands to create the applications from the template:\n\n```\noc new-app gse-liberty-deploy -p APPLICATION_NAME=cos-liberty -p DB2_HOST=<your DB2 host> -p DB2_PORT=<your DB2 host> -p DB2_USER=<your DB2 user> -p DB2_PASSWORD=<your DB2 password> -n cos-liberty-dev\noc new-app gse-liberty-deploy -p APPLICATION_NAME=cos-liberty -p DB2_HOST=<your DB2 host> -p DB2_PORT=<your DB2 host> -p DB2_USER=<your DB2 user> -p DB2_PASSWORD=<your DB2 password> -n cos-liberty-stage\noc new-app gse-liberty-deploy -p APPLICATION_NAME=cos-liberty -p DB2_HOST=<your DB2 host> -p DB2_PORT=<your DB2 host> -p DB2_USER=<your DB2 user> -p DB2_PASSWORD=<your DB2 password> -n cos-liberty-prod\n```\n\n### Import the build templates\nIn this step a template for the `build` process will be loaded in to the `build` project. The template provided [here](https://github.com/ibm-cloud-architecture/appmod-liberty-jenkins/blob/master/Deployment/OpenShift/template-liberty-build.yaml) defines the following artifacts:\n\n- An [ImageStream](https://docs.openshift.com/container-platform/3.11/dev_guide/managing_images.html) for the application image. This will be populated by the Jenkins Pipeline\n- An ImageStream for WebSphere Liberty which will pull down the latest version of the `ibmcom/websphere-liberty:kernel-ubi-min` image and will monitor DockerHub for any updates.\n- A `binary` [BuildConfig](https://docs.openshift.com/container-platform/3.11/dev_guide/builds/build_strategies.html) that will be used by the Jenkins Pipeline to build the application Docker image\n- A `jenkinsfile` BuildConfig that defines the `Pipeline` using the `Jenkinsfile` in GitHub\n- Parameters to allow the WebSphere Liberty image and GitHub repository to be provided when the template is instantiated\n\nIssue the commands below to load the template named `gse-liberty-build` in the `build` projects.\n\n```\noc create -f template-liberty-build.yaml -n cos-liberty-build\n```\n\n### Create the build definitions\nIn this step the `gse-liberty-build` template will be used to create a Red Hat OpenShift [application](https://docs.openshift.com/container-platform/3.11/dev_guide/application_lifecycle/new_app.html) named `cos-liberty` in the `build` namespaces.\n\nThe result will be:\n\n- An [ImageStream](https://docs.openshift.com/container-platform/3.11/dev_guide/managing_images.html) for the application image. This will be populated by the Jenkins Pipeline\n- An ImageStream for WebSphere Liberty which will pull down the latest version of the `ibmcom/websphere-liberty:kernel-ubi-min` image and will monitor DockerHub for any updates.\n- A `binary` [BuildConfig](https://docs.openshift.com/container-platform/3.11/dev_guide/builds/build_strategies.html) that will be used by the Jenkins Pipeline to build the application Docker image\n- A `jenkinsfile` BuildConfig that defines the `Pipeline` using the `Jenkinsfile` in GitHub (with the URL provided as a parameter when the application is created)\n\nIssue the following commands to create the application from the template:\n\n```\noc new-app gse-liberty-build -p APPLICATION_NAME=cos-liberty -p SOURCE_URL=\"https://github.com/ibm-cloud-architecture/appmod-liberty-jenkins\" -p SOURCE_REF=\"master\" -n cos-liberty-build\n```\n\n### Run the pipeline on OCP 4.3\nThe newly created pipeline can be started from the Red Hat OpenShift console which allows access to the Jenkins logs but also tracks the progress in the OCP console.\n\n- In the OpenShift Container Platform UI, change to the **Developer** view, select the `cos-liberty-build` project.\n\n- Select **Builds** and then select `cos-liberty-pipeline`\n\n- Click the **Start Build** button from the **Actions** dropdown\n  ![Run Pipeline](images/liberty-deploy/4.x-build-pipeline.jpg)\n\n- When the pipeline starts, click the `view log` link to go to the Jenkins administration console. Note that it may take a couple of minutes before the `view log` link appears on the first pipeline build\n  ![View Log](images/liberty-deploy/4.x-view-log.jpg)\n\n- When prompted, log in with your OpenShift account and grant the required access permissions. The Jenkins console log will be displayed as shown below:\n  ![Jenkins Log](images/liberty-deploy/jenkins-log.jpg)\n\n- Return to the OpenShift Console and track the progress of the pipeline\n  ![Running](images/liberty-deploy/4.x-pipeline-running.jpg)\n\n- The pipeline will eventually stop at the **Promotion Gate** for approval to deploy to Production. Click the **Input Required** link as shown below\n  ![Gate](images/liberty-deploy/4.x-gate.jpg)\n\n- When the *Promote application to Production* question is displayed, click **Proceed**\n  ![Promote](images/liberty-deploy/4.x-promote.jpg)\n\n- Return to the OpenShift Console and validate that the pipeline is now complete\n  ![Complete](images/liberty-deploy/4.x-complete.jpg)\n\n## Validate the Application on OCP 4.3\nNow that the pipeline is complete, validate the Customer Order Services application is deployed and running in `dev`, `stage` and `prod`\n\n- In the OpenShift Console, navigate to **Topology** view and click on the cos-liberty pod to view pod details, including images\n\n#### Topology\n  ![Deployment](images/liberty-deploy/4.x-deployment.jpg)\n\n#### Containers\n  ![Deployment](images/liberty-deploy/4.x-pods.jpg)\n\n- From the Topography view, you can also view the **route** for the application. Note that the URL is < application_name >-< project_name >.< ocp cluster url >. In this case the project name is `cos-liberty-dev`\n  ![Route](images/liberty-deploy/4.x-routes.jpg)\n\n- Add `/CustomerOrderServicesWeb` to the end of the URL in the browser to access the application\n  ![Dev Running](images/liberty-deploy/dev-running.jpg)\n\n- Log in to the application with `username: rbarcia` and `password: bl0wfish`\n\n- Repeat the validations for the `stage` and `prod` Projects.\n\n## Review and Next Steps\nIn this section you configured a CI/CD pipeline for the CustomerOrderServices application that builds a single immutable image for the latest version of the application and then deploys it to three different environments.\n","type":"Mdx","contentDigest":"6e1cf058cb0887e8ae544b5ae8b73aa6","counter":456,"owner":"gatsby-plugin-mdx"},"frontmatter":{"title":"Modernizing runtimes with Liberty - Deploy using Jenkins on OCP 4.3","description":"This section covers how to deploy the application to Red Hat OpenShift 4.3 using a Jenkins automated CI/CD pipeline. The diagram below shows the flow of the pipeline which starts when the developer checks their code in to Git and ends with the application being deployed in Production."},"exports":{},"rawBody":"---\ntitle: Modernizing runtimes with Liberty - Deploy using Jenkins on OCP 4.3\ndescription: This section covers how to deploy the application to Red Hat OpenShift 4.3 using a Jenkins automated CI/CD pipeline. The diagram below shows the flow of the pipeline which starts when the developer checks their code in to Git and ends with the application being deployed in Production.\n---\n\nexport const Title = () => (\n  <span>\nModernizing runtimes with Liberty <br/> <h2>Deploy using Jenkins on OCP 4.3</h2>\n  </span>\n);\n\n<PageDescription>\nThis section covers how to deploy the application to Red Hat OpenShift 4.3 using a Jenkins automated CI/CD pipeline. The diagram below shows the flow of the pipeline which starts when the developer checks their code in to Git and ends with the application being deployed in Production.\n</PageDescription>\n\n  ![Pipeline](images/liberty-deploy/overview.jpg)\n\n  1. the developer checks their code in to `git`\n  2. a `webhook` automatically triggers the Jenkins Pipeline in the RHOS cluster\n  3. the pipeline checks out the code from `git` and uses `maven` to build and test the application\n  4. the `oc start build` command is used to build a `docker` image for the application\n  5. the image is added to the `ImageStream` and pushed to the `docker registry` in the RHOS cluster\n  6. the image is then `tagged` for the `dev` project\n  7. the `deployment` running in the `dev` project is restarted using the newly created image\n  8. the image is then `tagged` for the `stage` project\n  9. the `deployment` running in the `stage` project is restarted using the newly created image\n  10. the developer is prompted to `approve` the deployment to production\n  11. the image is then `tagged` for the `prod` project\n  12. the `deployment` running in the `prod` project is restarted using the newly created image\n\n## Deploy the Application\nThe following steps will deploy the modernized Customer Order Services application in a WebSphere Liberty container to a Red Hat OpenShift cluster.\n\n### Prerequisites\nYou will need the following:\n\n- [Git CLI](https://git-scm.com/book/en/v2/Getting-Started-Installing-Git)\n- Red Hat OpenShift 4.3 with Cluster Admin permissions\n- [oc CLI](https://docs.openshift.com/container-platform/3.11/cli_reference/get_started_cli.html)\n- DB2 Database\n\n### Getting the project repository\nYou can clone the repository from its main GitHub repository page and checkout the appropriate branch for this version of the application.\n\n```\ngit clone https://github.com/ibm-cloud-architecture/appmod-liberty-jenkins.git\ncd appmod-liberty-jenkins\n```\n\n### Create application database infrastructure\nAs said in the prerequisites section above, the Customer Order Services application uses uses DB2 as its database. Follow these steps to create the appropriate database, tables and data the application needs to:\n\n- Copy the createOrderDB.sql and initialDataSet.sql files you can find in the Common directory of this repository over to the db2 host machine (or git clone the repository) in order to execute them later.\n\n- ssh into the db2 host\n\n- Change to the db2 instance user: `su {database_instance_name}``\n\n- Start db2: `db2start`\n\n- Create the ORDERDB database: `db2 create database ORDERDB`\n\n- Connect to the ORDERDB database: `db2 connect to ORDERDB`\n\n- Execute the createOrderDB.sql script you copied over in step 1 in order to create the appropriate tables, relationships, primary keys, etc: `db2 -tf createOrderDB.sql`\n\n- Execute the initialDataSet.sql script you copied over in step 1 to populate the ORDERDB database with the needed initial data set: `db2 -tf initialDataSet.sql`\n\nIf you want to re-run the scripts, please make sure you drop the databases and create them again.\n\n### Create the Security Context Constraint\nIn order to deploy and run the WebSphere Liberty Docker image in an OpenShift cluster, we first need to configure certain security aspects for the cluster. The `Security Context Constraint` provided [here](https://github.com/ibm-cloud-architecture/appmod-liberty-jenkins/blob/master/Deployment/OpenShift/ssc.yaml) grants the [service account](https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/) that the WebSphere Liberty Docker container is running under the required privileges to function correctly.\n\n### Create the projects\nFour Red Hat OpenShift projects are required in this scenario:\n\n- Build: this project will contain the Jenkins server and the artifacts used to build the application image\n- Dev: this is the `development` environment for this application\n- Stage: this is the `staging` environment for this application\n- Prod: this is the `production` environment for this application\n\nThe file provided [here](https://github.com/ibm-cloud-architecture/appmod-liberty-jenkins/blob/master/Deployment/OpenShift/liberty-projects.yaml) contains the definitions for the four projects in a single file to make creation easier\n\nIssue the command shown below to create the projects\n```\noc create -f liberty-projects.yaml\n```\n\n### Deploy Jenkins\nSome Red Hat OpenShift clusters are configured to automatically provision a Jenkins instance in a build project. The steps below can be used if your cluster is not configured for automatic Jenkins provisioning:\n\n```\noc project cos-liberty-build\noc new-app jenkins-persistent\n```\n\n## Update the Jenkins service account\nDuring provisioning of the Jenkins master a service account with the name `jenkins` is created. This service account has privileges to create new artifacts only in the project that it is running in. In this scenario Jenkins will need to create artifacts in the `dev`, `stage` and `prod` projects.\n\nIssue the commands below to allow the `jenkins` service account to `edit` artifacts in the `dev`, `stage` and `prod` projects.\n\n```\noc policy add-role-to-user edit system:serviceaccount:cos-liberty-build:jenkins -n cos-liberty-dev\noc policy add-role-to-user edit system:serviceaccount:cos-liberty-build:jenkins -n cos-liberty-stage\noc policy add-role-to-user edit system:serviceaccount:cos-liberty-build:jenkins -n cos-liberty-prod\n```\n\n### Import the deployment templates\nRed Hat OpenShift [templates](https://docs.openshift.com/container-platform/3.11/dev_guide/templates.html) are used to make artifact creation easier and repeatable. The template definition provided [here](https://github.com/ibm-cloud-architecture/appmod-liberty-jenkins/blob/master/Deployment/OpenShift/template-liberty-deploy.yaml) defines a Kubernetes [`Service`](https://kubernetes.io/docs/concepts/services-networking/service/), [`Route`](https://docs.openshift.com/container-platform/3.11/architecture/networking/routes.html) and [`DeploymentConfig`](https://docs.openshift.com/container-platform/3.11/architecture/core_concepts/deployments.html#deployments-and-deployment-configurations) for the CustomerOrderServices application.\n\nThe `gse-liberty-deploy` template defines the following:\n\n- `service` listening on ports `9080`, `9443` and `9082`\n- `route` to expose the `9443` port externally\n- `DeploymentConfig` to host the WebSphere Liberty container.\n    - The `image` for the container is taken from the [`ImageStream`](https://docs.openshift.com/container-platform/3.11/dev_guide/managing_images.html) that will be populated by the Jenkins pipeline.\n    - `environment variables` are defined for the DB2 database used by the application allowing for environment specific information to be injected\n    - [Probes](https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-probes/) for `liveness` and `readiness` are defined to check port 9443 is active\n    - The `securityContext` is set to allow read/write access to the filesystem and to run the container as `user 1001`\n    - The deployment will be updated if a new image is loaded to the `ImageStream` or if a change to the configuration is detected.\n\nIssue the commands below to load the template named `gse-liberty-deploy` in the `dev`, `stage` and `prod` projects.\n\n```\noc create -f template-liberty-deploy.yaml -n cos-liberty-dev\noc create -f template-liberty-deploy.yaml -n cos-liberty-stage\noc create -f template-liberty-deploy.yaml -n cos-liberty-prod\n```\n\n### Create the deployment definitions\nIn this step the `gse-liberty-deploy` template will be used to create a Red Hat OpenShift [application](https://docs.openshift.com/container-platform/3.11/dev_guide/application_lifecycle/new_app.html) named `cos-liberty` in the `dev`, `stage` and `prod` namespaces.\n\nThe result will be:\n\n- `service` listening on ports `9080`, `9443` and `9082`\n- `route` to expose the `9443` port externally\n- `DeploymentConfig` to host the WebSphere Liberty container. The deployment config will wait for a `docker image` to be loaded in to the `ImageStream` by the Jenkins pipeline.\n\nIssue the following commands to create the applications from the template:\n\n```\noc new-app gse-liberty-deploy -p APPLICATION_NAME=cos-liberty -p DB2_HOST=<your DB2 host> -p DB2_PORT=<your DB2 host> -p DB2_USER=<your DB2 user> -p DB2_PASSWORD=<your DB2 password> -n cos-liberty-dev\noc new-app gse-liberty-deploy -p APPLICATION_NAME=cos-liberty -p DB2_HOST=<your DB2 host> -p DB2_PORT=<your DB2 host> -p DB2_USER=<your DB2 user> -p DB2_PASSWORD=<your DB2 password> -n cos-liberty-stage\noc new-app gse-liberty-deploy -p APPLICATION_NAME=cos-liberty -p DB2_HOST=<your DB2 host> -p DB2_PORT=<your DB2 host> -p DB2_USER=<your DB2 user> -p DB2_PASSWORD=<your DB2 password> -n cos-liberty-prod\n```\n\n### Import the build templates\nIn this step a template for the `build` process will be loaded in to the `build` project. The template provided [here](https://github.com/ibm-cloud-architecture/appmod-liberty-jenkins/blob/master/Deployment/OpenShift/template-liberty-build.yaml) defines the following artifacts:\n\n- An [ImageStream](https://docs.openshift.com/container-platform/3.11/dev_guide/managing_images.html) for the application image. This will be populated by the Jenkins Pipeline\n- An ImageStream for WebSphere Liberty which will pull down the latest version of the `ibmcom/websphere-liberty:kernel-ubi-min` image and will monitor DockerHub for any updates.\n- A `binary` [BuildConfig](https://docs.openshift.com/container-platform/3.11/dev_guide/builds/build_strategies.html) that will be used by the Jenkins Pipeline to build the application Docker image\n- A `jenkinsfile` BuildConfig that defines the `Pipeline` using the `Jenkinsfile` in GitHub\n- Parameters to allow the WebSphere Liberty image and GitHub repository to be provided when the template is instantiated\n\nIssue the commands below to load the template named `gse-liberty-build` in the `build` projects.\n\n```\noc create -f template-liberty-build.yaml -n cos-liberty-build\n```\n\n### Create the build definitions\nIn this step the `gse-liberty-build` template will be used to create a Red Hat OpenShift [application](https://docs.openshift.com/container-platform/3.11/dev_guide/application_lifecycle/new_app.html) named `cos-liberty` in the `build` namespaces.\n\nThe result will be:\n\n- An [ImageStream](https://docs.openshift.com/container-platform/3.11/dev_guide/managing_images.html) for the application image. This will be populated by the Jenkins Pipeline\n- An ImageStream for WebSphere Liberty which will pull down the latest version of the `ibmcom/websphere-liberty:kernel-ubi-min` image and will monitor DockerHub for any updates.\n- A `binary` [BuildConfig](https://docs.openshift.com/container-platform/3.11/dev_guide/builds/build_strategies.html) that will be used by the Jenkins Pipeline to build the application Docker image\n- A `jenkinsfile` BuildConfig that defines the `Pipeline` using the `Jenkinsfile` in GitHub (with the URL provided as a parameter when the application is created)\n\nIssue the following commands to create the application from the template:\n\n```\noc new-app gse-liberty-build -p APPLICATION_NAME=cos-liberty -p SOURCE_URL=\"https://github.com/ibm-cloud-architecture/appmod-liberty-jenkins\" -p SOURCE_REF=\"master\" -n cos-liberty-build\n```\n\n### Run the pipeline on OCP 4.3\nThe newly created pipeline can be started from the Red Hat OpenShift console which allows access to the Jenkins logs but also tracks the progress in the OCP console.\n\n- In the OpenShift Container Platform UI, change to the **Developer** view, select the `cos-liberty-build` project.\n\n- Select **Builds** and then select `cos-liberty-pipeline`\n\n- Click the **Start Build** button from the **Actions** dropdown\n  ![Run Pipeline](images/liberty-deploy/4.x-build-pipeline.jpg)\n\n- When the pipeline starts, click the `view log` link to go to the Jenkins administration console. Note that it may take a couple of minutes before the `view log` link appears on the first pipeline build\n  ![View Log](images/liberty-deploy/4.x-view-log.jpg)\n\n- When prompted, log in with your OpenShift account and grant the required access permissions. The Jenkins console log will be displayed as shown below:\n  ![Jenkins Log](images/liberty-deploy/jenkins-log.jpg)\n\n- Return to the OpenShift Console and track the progress of the pipeline\n  ![Running](images/liberty-deploy/4.x-pipeline-running.jpg)\n\n- The pipeline will eventually stop at the **Promotion Gate** for approval to deploy to Production. Click the **Input Required** link as shown below\n  ![Gate](images/liberty-deploy/4.x-gate.jpg)\n\n- When the *Promote application to Production* question is displayed, click **Proceed**\n  ![Promote](images/liberty-deploy/4.x-promote.jpg)\n\n- Return to the OpenShift Console and validate that the pipeline is now complete\n  ![Complete](images/liberty-deploy/4.x-complete.jpg)\n\n## Validate the Application on OCP 4.3\nNow that the pipeline is complete, validate the Customer Order Services application is deployed and running in `dev`, `stage` and `prod`\n\n- In the OpenShift Console, navigate to **Topology** view and click on the cos-liberty pod to view pod details, including images\n\n#### Topology\n  ![Deployment](images/liberty-deploy/4.x-deployment.jpg)\n\n#### Containers\n  ![Deployment](images/liberty-deploy/4.x-pods.jpg)\n\n- From the Topography view, you can also view the **route** for the application. Note that the URL is < application_name >-< project_name >.< ocp cluster url >. In this case the project name is `cos-liberty-dev`\n  ![Route](images/liberty-deploy/4.x-routes.jpg)\n\n- Add `/CustomerOrderServicesWeb` to the end of the URL in the browser to access the application\n  ![Dev Running](images/liberty-deploy/dev-running.jpg)\n\n- Log in to the application with `username: rbarcia` and `password: bl0wfish`\n\n- Repeat the validations for the `stage` and `prod` Projects.\n\n## Review and Next Steps\nIn this section you configured a CI/CD pipeline for the CustomerOrderServices application that builds a single immutable image for the latest version of the application and then deploys it to three different environments.\n","fileAbsolutePath":"/home/runner/work/modernization-playbook/modernization-playbook/src/pages/applications/liberty/liberty-deploy-43-jenkins.mdx"}}},"staticQueryHashes":["1054721580","1054721580","1364590287","2102389209","2102389209","2456312558","2746626797","3018647132","3037994772","768070550"]}